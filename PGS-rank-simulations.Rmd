---
title: "PGS simulations"
output: html_document
date: "2025-06-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Sampling PGS relative rankings

Collect PGS rankings, correlations and proportions in one loop.
```{r}
source("PGSvariance.R")
M = 1000 # of SNPs
h2s = c(0.1, 0.25, 0.5, 0.8) # heritabilities
Ns = c(1000, 10000, 100000, 250000, 500000) # of individuals in GWAS training data
n.samples = 10000 #
t = 0.9 # 
n = 10000 # of indivuduals whose PGSs are computed
n.stats = 5 # of statistics to be collected for each individual
len.h2 = length(h2s) # of different heritabilities

ranking.stats = matrix(nrow = n, ncol = length(h2s) * n.stats * length(Ns)) 
rank.correlations = matrix(nrow = n, ncol = length(h2s)*length(Ns)) 
proportions = matrix(nrow = n, ncol = length(h2s)*length(Ns)) # proportion of PGS estimates over t for each individual, for each N and h2

for (i in 1:length(Ns)){
  for (j in 1:length(h2s)){
    pgs.sample.rankings = PGS.sample.rankings(Ns[i], M, n, h2s[j], n.samples, S = -1, t)
    
    # collect stats
    rankings = pgs.sample.rankings$pgs.rankings
    # output is a (n x n.samples) matrix of rankings of n.samples PGS estimates for n individuals
    mean = rowMeans(rankings) # mean PGS for each individual
    median = apply(rankings, 1, median) # median PGS for each individual
    min.ranking = apply(rankings, 1, min) # minimums of individuals' rankings
    max.ranking = apply(rankings, 1, max) # maximums of individuals' rankings
    range = max.ranking - min.ranking # range of rankings of an individual
    col.start = ((i - 1) * len.h2 + (j - 1)) * n.stats + 1
    col.end = col.start + n.stats - 1

    ranking.stats[, col.start:col.end] = c(mean, median, min.ranking, max.ranking, range)
    
    # compute rank correlations
    rank.correlations[,((i-1)*length(h2s)+j)] = compute.rank.correlations(rankings)
    
    # collect proportions
    pgs.prop = pgs.sample.rankings$prop.over.t
    proportions[,((i-1)*length(h2s)+j)] = pgs.prop
  }
  
}

```


### Range of rankings and mean/median rankings

```{r}
stat.names = c("mean", "median", "min", "max", "range")
col.names = c()

for (i in seq_along(Ns)) {
  for (j in seq_along(h2s)) {
    for (stat in stat.names) {
      col.names = c(col.names, paste0("N", Ns[i], ".h2.", h2s[j], ".", stat))
    }
  }
}
colnames(ranking.stats) = col.names # set column names

head(ranking.stats)

```

```{r}
# mean range of rankings for each N and h2
range.cols = seq(from = n.stats, to = ncol(ranking.stats), by = n.stats)
range.means = colMeans(ranking.stats[,range.cols])

range.mat = matrix(range.means, nrow = length(Ns), ncol = length(h2s), byrow = FALSE) # format

rownames(range.mat) = paste0("N = ", Ns)
colnames(range.mat) = paste0("h2 = ", h2s)

range.mat
```

### Proportion of individual PGS estimates over t

```{r}
col.names = c()

for (i in seq_along(Ns)) {
  for (j in seq_along(h2s)) {
      col.names = c(col.names, paste0("N", Ns[i], ".h2.", h2s[j]))
  }
}
colnames(proportions) = col.names # set column names

```

```{r}
apply(proportions, 2, max)
```

```{r}
# Split into groups for clearer plotting
n.groups = 10  # number of groups 

group.means = matrix(NA, nrow = n.groups, ncol = ncol(proportions)) # a matrix to store means: rows = groups, cols = N-h2-groups

for (col.idx in 1:(ncol(proportions))) { # iterate over columns (N-h2-groups)
  col.values = proportions[, col.idx] 
  
  ordered.indices = order(col.values, decreasing = TRUE) # order indices by decreasing value
  
  group.sizes = rep(floor(length(col.values)/n.groups), n.groups) # split indices into n.groups equal groups
  remainder = length(col.values) %% n.groups # check if jako ei mennyt tasan
  if (remainder > 0) { 
    group.sizes[1:remainder] = group.sizes[1:remainder] + 1 # add one to remainder first groups
  }
  
  groups = rep(1:n.groups, times = group.sizes) # assign groups to indices
  grouped.values = split(col.values[ordered.indices], groups) # get the values as a list of groups
  group.means[, col.idx] = sapply(grouped.values, mean, na.rm = TRUE) # compute means for each group
}

rownames(group.means) = paste0("Group", 1:n.groups)
colnames(group.means) = colnames(proportions)


```

```{r}
library(reshape2)
library(ggplot2)

n.individuals = nrow(proportions) # dimensions (n)

N.rep = rep(Ns, each = length(h2s)) # metadata for the columns
h2.rep = rep(h2s, times = length(Ns))

prop.df = as.data.frame(group.means) # convert to data frame
colnames(prop.df) = paste0("N", N.rep, ".h2.", h2.rep)

prop.long = melt(prop.df, variable.name = "Condition", value.name = "Proportion") # reshape to long format

prop.long$N = as.numeric(sub("^N([0-9.e+-]+)\\.h2\\..*$", "\\1", prop.long$Condition))
prop.long$h2 = as.numeric(sub(".*\\.h2\\.(.*)", "\\1", prop.long$Condition))

prop.long
```

```{r}
ggplot(prop.long, aes(x = as.numeric(factor(N), -0.3, 0.3), 
                      y = Proportion, 
                      color = factor(h2))) +
  geom_point(alpha = 0.6, size = 2) +
  scale_x_continuous(breaks = 1:length(Ns), labels = Ns) +
  labs(x = "Sample size (N)", y = "Proportion", color = "h²") +
  theme_minimal()


```
Proportion of individual PGSs over threshold t approaches either 1 or 0 with increasing sample size and heritability.


## Order-correlation of sampled PGS estimates

```{r}
col.names = c()
N.names = c()
h2.names = c()

for (i in seq_along(Ns)) {
  for (j in seq_along(h2s)) {
      col.names = c(col.names, paste0("N", Ns[i], ".h2.", h2s[j]))
      N.names = c(N.names, Ns[i])
      h2.names = c(h2.names, h2s[j])
  }
}
colnames(rank.correlations) = col.names # set column names
head(rank.correlations)
colMeans(rank.correlations)

```

```{r}
# violin plot rank correlations
rank.df = as.data.frame(rank.correlations) # to df
rank.df$N = N.names
rank.df$h2 = h2.names
rank.long = melt(rank.df, variable.name = "Condition", value.name = "Correlation") # reshape to long format

rank.long$N = as.numeric(sub("^N([0-9.e+-]+)\\.h2\\..*$", "\\1", rank.long$Condition))
rank.long$h2 = as.numeric(sub(".*\\.h2\\.(.*)", "\\1", rank.long$Condition))
rank.long[170000, ]

ggplot(rank.long, aes(x = as.numeric(factor(N)), y = Correlation, fill = factor(h2), group = h2)) +
  geom_violin(fill = h2) +
  labs(x = "Sample size (N)", fill = "h²") +
  theme_minimal()


```




2 samples for each individual
-> correlation, plot all individual correlations as a violin plot,
    with different h2 and N


