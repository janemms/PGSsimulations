---
title: "PGS simulations"
output: html_document
date: "2025-06-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Sampling PGS relative rankings

Collect PGS rankings, correlations and proportions in one loop.
```{r}
source("PGSvariance.R")
M = 1000 # of SNPs
h2s = c(0.1, 0.25, 0.5, 0.8) # heritabilities
Ns = c(1000, 10000, 100000, 250000, 500000) # of individuals in GWAS training data
n.samples = 10000 #
t = 0.9 # 
n = 10000 # of indivuduals whose PGSs are computed
n.stats = 5 # of statistics to be collected for each individual
len.h2 = length(h2s) # of different heritabilities

ranking.stats = matrix(nrow = n, ncol = length(h2s) * n.stats * length(Ns)) 
rank.correlations = matrix(nrow = n, ncol = length(h2s)*length(Ns)) 
proportions = matrix(nrow = n, ncol = length(h2s)*length(Ns)) # proportion of PGS estimates over t for each individual, for each N and h2

for (i in 1:length(Ns)){
  for (j in 1:length(h2s)){
    pgs.sample.rankings = PGS.sample.rankings(Ns[i], M, n, h2s[j], n.samples, S = -1, t)
    
    # collect stats
    rankings = pgs.sample.rankings$pgs.rankings
    # output is a (n x n.samples) matrix of rankings of n.samples PGS estimates for n individuals
    mean = rowMeans(rankings) # mean PGS for each individual
    median = apply(rankings, 1, median) # median PGS for each individual
    min.ranking = apply(rankings, 1, min) # minimums of individuals' rankings
    max.ranking = apply(rankings, 1, max) # maximums of individuals' rankings
    range = max.ranking - min.ranking # range of rankings of an individual
    col.start = ((i - 1) * len.h2 + (j - 1)) * n.stats + 1
    col.end = col.start + n.stats - 1

    ranking.stats[, col.start:col.end] = c(mean, median, min.ranking, max.ranking, range)
    
    # compute rank correlations
    rank.correlations[,((i-1)*length(h2s)+j)] = compute.rank.correlations(rankings)
    
    # collect proportions
    pgs.prop = pgs.sample.rankings$prop.over.t
    proportions[,((i-1)*length(h2s)+j)] = pgs.prop
  }
  
}

```


### Range of rankings and mean/median rankings

```{r}
stat.names = c("mean", "median", "min", "max", "range")
col.names = c()

for (i in seq_along(Ns)) {
  for (j in seq_along(h2s)) {
    for (stat in stat.names) {
      col.names = c(col.names, paste0("N", Ns[i], ".h2.", h2s[j], ".", stat))
    }
  }
}
colnames(ranking.stats) = col.names # set column names

head(ranking.stats)

```

```{r}
# mean range of rankings for each N and h2
range.cols = seq(from = n.stats, to = ncol(ranking.stats), by = n.stats)
range.means = colMeans(ranking.stats[,range.cols])

range.mat = matrix(range.means, nrow = length(Ns), ncol = length(h2s), byrow = FALSE) # format

rownames(range.mat) = paste0("N = ", Ns)
colnames(range.mat) = paste0("h2 = ", h2s)

range.mat
```

### Proportion of individual PGS estimates over t

```{r}
col.names = c()

for (i in seq_along(Ns)) {
  for (j in seq_along(h2s)) {
      col.names = c(col.names, paste0("N", Ns[i], ".h2.", h2s[j]))
  }
}
colnames(proportions) = col.names # set column names

```

```{r}
apply(proportions, 2, max)
```

```{r}
# Split into groups for clearer plotting
n.groups = 10  # number of groups 

group.means = matrix(NA, nrow = n.groups, ncol = ncol(proportions)) # a matrix to store means: rows = groups, cols = N-h2-groups

for (col.idx in 1:(ncol(proportions))) { # iterate over columns (N-h2-groups)
  col.values = proportions[, col.idx] 
  
  ordered.indices = order(col.values, decreasing = TRUE) # order indices by decreasing value
  
  group.sizes = rep(floor(length(col.values)/n.groups), n.groups) # split indices into n.groups equal groups
  remainder = length(col.values) %% n.groups # check if jako ei mennyt tasan
  if (remainder > 0) { 
    group.sizes[1:remainder] = group.sizes[1:remainder] + 1 # add one to remainder first groups
  }
  
  groups = rep(1:n.groups, times = group.sizes) # assign groups to indices
  grouped.values = split(col.values[ordered.indices], groups) # get the values as a list of groups
  group.means[, col.idx] = sapply(grouped.values, mean, na.rm = TRUE) # compute means for each group
}

rownames(group.means) = paste0("Group", 1:n.groups)
colnames(group.means) = colnames(proportions)


```

```{r}
library(reshape2)
library(ggplot2)

n.individuals = nrow(proportions) # dimensions (n)

N.rep = rep(Ns, each = length(h2s)) # metadata for the columns
h2.rep = rep(h2s, times = length(Ns))

prop.df = as.data.frame(group.means) # convert to data frame
colnames(prop.df) = paste0("N", N.rep, ".h2.", h2.rep)

prop.long = melt(prop.df, variable.name = "Condition", value.name = "Proportion") # reshape to long format

prop.long$N = as.numeric(sub("^N([0-9.e+-]+)\\.h2\\..*$", "\\1", prop.long$Condition))
prop.long$h2 = as.numeric(sub(".*\\.h2\\.(.*)", "\\1", prop.long$Condition))

prop.long
```

```{r}
ggplot(prop.long, aes(x = as.numeric(factor(N), -0.3, 0.3), 
                      y = Proportion, 
                      color = factor(h2))) +
  geom_point(alpha = 0.6, size = 2) +
  scale_x_continuous(breaks = 1:length(Ns), labels = Ns) +
  labs(x = "Sample size (N)", y = "Proportion", color = "h²") +
  theme_minimal()


```
Proportion of individual PGSs over threshold t approaches either 1 or 0 with increasing sample size and heritability.


## Order-correlation of sampled PGS estimates

```{r}
col.names = c()
N.names = c()
h2.names = c()

for (i in seq_along(Ns)) {
  for (j in seq_along(h2s)) {
      col.names = c(col.names, paste0("N", Ns[i], ".h2.", h2s[j]))
      N.names = c(N.names, Ns[i])
      h2.names = c(h2.names, h2s[j])
  }
}
colnames(rank.correlations) = col.names # set column names
head(rank.correlations)
colMeans(rank.correlations)

```

```{r}
# violin plot rank correlations
rank.df = na.omit(as.data.frame(rank.correlations)) # to df
rank.df$N = N.names
rank.df$h2 = h2.names
rank.long = melt(rank.df, variable.name = "Condition", value.name = "Correlation") # reshape to long format

rank.long$N = as.numeric(sub("^N([0-9.e+-]+)\\.h2\\..*$", "\\1", rank.long$Condition))
rank.long$h2 = as.numeric(sub(".*\\.h2\\.(.*)", "\\1", rank.long$Condition))

plot.df = rank.long[rank.long$h2 == h2s[1], ]

plot.df$N <- factor(plot.df$N)       # treat N as categorical for x-axis


for (i in 1:length(h2s)){
  plot.df = rank.long[rank.long$h2 == h2s[i], ]
  pl = ggplot(na.omit(plot.df), aes(factor(N), Correlation))
  print(pl + geom_violin(scale="count") +
  labs(x = "Sample size (N)", fill = "h²") +
  ylim(-0.05,1) +
  theme_minimal())

}



```

# Visualization of individual PGS estimates

#### Individual PGS rankings
```{r}
source("PGSvariance.R")
M = 1000 # of SNPs
h2 = 0.5 # c(0.1, 0.25, 0.5, 0.8) # heritabilities
N = 50000 # of individuals in GWAS training data
n.samples = 100 #
t = 0.9 # 
n = 100 # of individuals whose PGSs are computed

v.rankings = PGS.sample.rankings(N, M, n, h2, n.samples, S = -1, t)

# plot rankings of a random individual
pgs.rankings = v.rankings$pgs.rankings
ind.rankings = pgs.rankings[30, ]

q.vals = rep(t * n, times = n.samples) #apply(pgs.rankings, 1, quantile, probs = t) # values at tth quantiles
col = ifelse(ind.rankings > q.vals, "above t", "below t")

df <- data.frame(x = ind.rankings, y = 0, col = factor(col, levels = c("below t", "above t")))

ggplot(df, aes(x = x, y = y, color = col)) +
  geom_point(position = position_jitter(height = 0.05), size = 2) +
  geom_vline(xintercept = t*n, linetype = "dashed", color = "black") +
  scale_color_manual(values = c("above t" = "red", "below t" = "blue")) +
  theme_minimal() +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  labs(
    title = "Distribution of individual PGS rankings",
    x = "Value",
    color = paste0("> ", t * 100, "th percentile")
  ) +
  coord_cartesian(ylim = c(-0.5, 0.5))

```


#### Individual PGS estimates
```{r}
source("PGSvariance.R")
M = 1000 # of SNPs
h2 = 0.5 # c(0.1, 0.25, 0.5, 0.8) # heritabilities
N = 50000 # of individuals in GWAS training data
n.samples = 100 #
t = 0.9 # 
n = 100 # of individuals whose PGSs are computed

v.rankings = PGS.sample.rankings(N, M, n, h2, n.samples, S = -1, t)

# plot rankings of a random individual
pgs.est = v.rankings$pgs.est
ind.est = pgs.est[30, ]

q.vals = apply(pgs.rankings, 1, quantile, probs = t) # values at t:th quantiles
col = ifelse(ind.rankings > q.vals, "above t", "below t")

df <- data.frame(x = ind.rankings, y = 0, col = factor(col, levels = c("below t", "above t")))

ggplot(df, aes(x = x, y = y, color = col)) +
  geom_point(position = position_jitter(height = 0.05), size = 2) +
  scale_color_manual(values = c("above t" = "red", "below t" = "blue")) +
  theme_minimal() +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  labs(
    title = "Distribution of individual PGS estimates",
    x = "Value",
    color = paste0("> ", t * 100, "th percentile")
  ) +
  coord_cartesian(ylim = c(-0.5, 0.5))

```

## Change in rankings, correlation and proportion over t for different N within individuals

Generate genotype data and true genetic effects
```{r}
source("PGSvariance.R")
M = 1000 # of SNPs
n = 10000 
h2 = 0.5
geno = generate.geno(M, n, h2, S = -1) # generate genotypes, betas and collect variance parameters
var = geno$var
beta = geno$beta
X = geno$X

```

```{r}
Ns = c(1000, 10000, 100000, 250000, 500000) # of individuals in GWAS training data
n.samples = 1000 # for each individual

props = matrix(nrow = 4, ncol = length(Ns)) # rows individuals, columns Ns
ranks = matrix(nrow = 4*length(Ns), ncol = n.samples)

for (i in 1:length(Ns)){
  rankings = PGS.sample.rankings.2(N, n.samples, X, var, beta, t = 0.9) 
  props[, i] = rankings$prop.over.t[1:4]  
  ranks[((i-1)*4 + 1): (i*4), ] = rankings$pgs.rankings[1:4, ]
  
  # compute.rank.correlations <- function(pgs.ranks, n.pairs = 1000, seed = 42) {
}
```

```{r}
library(patchwork)
# individuals 1, 2, 3 and 4
plots = list()
for (i in 1:4){ # individuals
  for (j in 1:length(Ns)){
    ind.rankings = ranks[(j-1)*4 + i, ]
    
    q.vals = rep(t * n, times = n.samples) #apply(pgs.rankings, 1, quantile, probs = t) # values at tth quantiles
    col = ifelse(ind.rankings > q.vals, "above t", "below t")
    
    df = data.frame(x = ind.rankings, y = 0, col = factor(col, levels = c("below t", "above t")))
    
    print(ggplot(df, aes(x = x, y = y, color = col)) +
      geom_point(position = position_jitter(height = 0.05), size = 2) +
      geom_vline(xintercept = t*n, linetype = "dashed", color = "black") +
      scale_color_manual(values = c("above t" = "red", "below t" = "blue")) +
      theme_minimal() +
      theme(
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank()
      ) +
      labs(
        title = paste0("Individual PGS rankings with N = ", Ns[j]),
        x = "Value",
        color = paste0("> ", t * 100, "th percentile")
      ) +
      coord_cartesian(ylim = c(-0.5, 0.5)))
    
  }
  
}

```

```{r}
props

```

