---
title: "PGS simulations"
output: html_document
date: "2025-06-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Sampling PGS relative rankings

```{r}
source("PGSvariance.R")
N = 500000
M = 1000
n = 10000
h2 = 0.7
n.samples = 10000
pgs.rankings = PGS.sample.rankings(N, M, n, h2, n.samples, S = -1, 0.9)
```

```{r}
rank.mat = pgs.rankings$pgs.rankings
#rank.mat
rowMeans(rank.mat)
#over.t[order(over.t, decreasing = TRUE)]
```

Largest "probabilities" of exceeding the threshold t are:
- < 20 % with h2 = 0.5, N = 100 000, M = 1000, n = 10 000, t = 0.9 and n.samples = 1000.
- 20-60% with h2 = 0.6, N = 100 000, M = 1000, n = 10 000, t = 0.9 and n.samples = 1000.

Incomplete loop
```{r}
# pgs.rankings = PGS.sample.rankings(N, M, n, h2, n.samples, S = -1, t = 0.9)

source("PGSvariance.R")
M = 1000 # of SNPs
h2s = c(0.1, 0.25, 0.5, 0.8) # heritabilities
Ns = c(1000, 10000, 100000, 250000, 500000) # of individuals
n.samples = 10000 #
t = 0.9 # 
n = 10000 
n.stats = 5 # of statistics to be collected for each individual

ranking.stats = matrix(nrow = length(Ns), ncol = length(h2s) * n.stats) 

for (j in 1:length(h2s)){
  for (i in 1:length(Ns)){
    rankings = PGS.sample.rankings(Ns[i], M, n, h2s[j], n.samples, S = -1, t)$pgs.rankings
    # output is a (n x n.samples) matrix of rankings of n.samples PGS estimates for n individuals
    mean = rowMeans(rankings) # mean PGS for each individual
    median = apply(rankings, 1, median) # median PGS for each individual
    min.ranking = apply(rankings, 1, min) # minimums of individuals' rankings
    max.ranking = apply(rankings, 1, max) # maximums of individuals' rankings
    range = max.ranking - min.ranking # range of rankings of an individual
    #sanity.check = colMeans(rankings)
    ranking.stats[i, ((j-1)*n.stats+1):(j*n.stats)] = c(mean, median, min.ranking, max.ranking, range)
    #
  }
  
 }
```

```{r}
source("PGSvariance.R")
M = 1000 # of SNPs
h2 = 0.5 # heritabilities
N = 500000 # of individuals
n.samples = 10000 #
t = 0.9 # 
n = 10000 
n.stats = 5 # of statistics to be collected for each individual

#ranking.stats = matrix(nrow = length(Ns), ncol = length(h2s) * n.stats) 


PGS.rankings = PGS.sample.rankings(N, M, n, h2, n.samples, S = -1, t)
rankings = PGS.rankings$pgs.rankings
# output is a (n x n.samples) matrix of rankings of n.samples PGS estimates for n individuals
mean = rowMeans(rankings) # mean PGS for each individual
median = apply(rankings, 1, median) # median PGS for each individual
min.ranking = apply(rankings, 1, min) # minimums of individuals' rankings
max.ranking = apply(rankings, 1, max) # maximums of individuals' rankings
range = max.ranking - min.ranking # range of rankings of an individual
#sanity.check = colMeans(rankings)
stats = cbind(mean, median, min.ranking, max.ranking, range)

```

```{r}
#order((stats[, 1]), decreasing = TRUE)
#stats[which(stats[,2] > 8000), ]
#stats[9988,]


#PGS.rankings$pgs
mean(PGS.rankings$pgs)
sd(PGS.rankings$pgs)
```

#### Proportion of individual PGS estimates over t

```{r}
source("PGSvariance.R")
M = 1000 # of SNPs
h2s = c(0.1, 0.25, 0.5, 0.8) # heritabilities
Ns = c(1000, 10000, 100000, 250000, 500000) # of individuals
n.samples = 10000 #
t = 0.9 # 
n = 10000 

proportions = matrix(nrow = n, ncol = length(h2s)*length(Ns)) # proportion of PGS estimates over t for each individual, for each N and h2

for (j in 1:length(h2s)){
  for (i in 1:length(Ns)){
    proportions[,((i-1)*length(h2s)+j)] = PGS.sample.rankings(Ns[i], M, n, h2s[j], n.samples, S = -1, t)$prop.over.t
  }
}
```

```{r}
colnames(proportions) = c("") # 


```

compute.rank.correlations <- function(pgs.ranks, n.pairs = 1000, seed = 42) {
  set.seed(seed)
  n.samples <- nrow(pgs.ranks)  # number of posterior samples
  
  if (n.samples < 2) {
    stop("Need at least 2 posterior samples to compute correlations.")
  }

  all.pairs <- combn(n.samples, 2)  # 2 × num_pairs matrix
  
  total.pairs <- ncol(all.pairs)
  sampled.indices <- sample(total.pairs, min(n.pairs, total.pairs))
  sampled.pairs <- all.pairs[, sampled.indices]  # still a 2 × k matrix

  # Now apply over columns of sampled.pairs
  corrs <- apply(sampled.pairs, 2, function(pair) {
    cor(pgs.ranks[pair[1], ], pgs.ranks[pair[2], ], method = "spearman")
  })

  return(corrs)
}

## Order-correlation of sampled PGS estimates
A function to compute the rank correlations
```{r} 
compute.rank.correlations <- function(pgs.ranks, n.pairs = 1000, seed = 42) {
  set.seed(seed)
  n.samples = nrow(pgs.ranks) # of samples (ranks) for each individual
  
  all.pairs = combn(n.samples, 2) # all unique combinations of indices of samples (2 x jotain) matrix
  nof.pairs = ncol(all.pairs) 
  sample.ind = sample(nof.pairs, min(n.pairs, length(all.pairs))) 
  #str(all.pairs)
  #str(sample.ind)
  sampled.pairs = as.matrix(all.pairs[,sample.ind, drop = FALSE]) # sample n.pairs of the sample pairs
  #str(sampled.pairs)
  corrs = apply(sampled.pairs, 2, function(pair){cor(pgs.ranks[pair[1],], pgs.ranks[pair[2],], method = "spearman")}) # compute Spearman correlations for the sampled pairs
  return(str(corrs))
}

```

```{r}
# n.samples ranks from each individual
N = 500000 # GWAS training sample size
M = 1000 # of SNPs
n = 10000 # of individuals whose PGS is computed
h2 = 0.5 # heritability
n.samples = 500 # of samples for each individual
t = 0.9

pgs.ranks = PGS.sample.rankings(N, M, n, h2, n.samples, S = -1, t)

ranks = pgs.ranks$pgs.rankings # n.samples rankings for each of the 10 000 individuals

#ord.cor = compute.rank.correlations(ranks) # compute rank correlations for pairs of individuals


```

```{r}
ord.cor = compute.rank.correlations(ranks) # compute rank correlations for pairs of individuals

ord.cor
```





2 samples for each individual
-> correlation, plot all individual correlations as a violin plot,
    with different h2 and N


